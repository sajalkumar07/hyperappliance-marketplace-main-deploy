# Development Roadmap for a Decentralized AIM & HyperBox Marketplace

This roadmap outlines a multi-phase plan to build a Next.js-based decentralized marketplace for HyperCycle‚Äôs AI ecosystem. The platform will allow users to **list, buy, deploy, and interact with Artificial Intelligence Modules (AIMs)**, and to **list and rent out HyperBoxes** (AI compute appliances) for running those AIMs. Each phase below includes key development steps, database schema guidance, smart contract integration points, UI/UX considerations, and best practices for scalability and security.

## Phase 1: Architecture Planning and Tech Stack

**Objectives:** Establish the overall architecture, choose technologies, and design the core components of the marketplace.

- **Tech Stack Selection:** Use **Next.js** for the frontend and server-side rendering. Leverage Next.js API routes (Node/Express) or a separate Node.js backend for handling server logic (e.g. AIM deployment calls, database queries). For the database, use a scalable option like PostgreSQL or MongoDB to store off-chain data (users, listings, messages, etc.). Ensure the design supports real-time updates (for messaging or AIM status) ‚Äì Next.js can integrate with libraries like Socket.IO or web3 event listeners as needed.
- **Component Breakdown:** Plan the system as modular services:
  - **Frontend:** React components for browsing AIMs and HyperBoxes, profile management, etc. Emphasize a clean UI with intuitive navigation (e.g. a top menu for ‚ÄúAIMs‚Äù, ‚ÄúCompute/HyperBoxes‚Äù, ‚ÄúMy Profile‚Äù, ‚ÄúMessages‚Äù). Keep the design mobile-responsive and use a UI framework (Chakra UI, Material UI, or custom CSS) for consistency.
  - **Backend:** Next.js API routes for business logic (e.g. onboarding flows, querying HyperBox specs, interacting with blockchains). Include a blockchain interaction module for EVM (using web3/ethers.js) and Cardano (using Mesh JS or Cardano Serialization lib) to handle wallet connections and contract calls.
  - **Blockchain Contracts:** Identify smart contracts needed. Likely an **AIM NFT contract** (ERC-721 or Cardano native asset) to represent AIM licenses/ownership, and possibly a **marketplace contract** to facilitate buying/selling these NFTs. For HyperBoxes, if node licenses are tokenized, plan to interface with those tokens as well.
- **High-Level Data Model:** Draft the main entities:
  - **User:** (id, username, profile info, linked wallets, reputation score, etc.)
  - **AIM:** (id, name, description, developer_id, metadata pointer/manifest, required_specs, price or license cost, etc.)
  - **HyperBox:** (id, owner_id, specs (CPU, GPU, RAM, location), availability status, usage rate, etc.)
  - **Deployment/Booking:** (id, aim_id, hyperbox_id, user_id (who deployed), start_time, end_time/status)
  - **Messages:** (id, sender_id, receiver_id, content, timestamp) ‚Äì for user communications.
- **UI/UX Planning:** Create wireframes for:
  - **Homepage:** showcasing featured AIMs and available HyperBoxes.
  - **AIM Listing Page:** grid or list of AIM cards with name, category, brief description, price/license info.
  - **HyperBox Listing Page:** list of available HyperBoxes with key specs (GPU type, RAM, location, price/hour).
  - **Filters/Search:** UI controls to filter AIMs by category/tags and HyperBoxes by specs (e.g. minimum GPU, region).
  - **Detail Pages:** A page for each AIM (with detailed description, endpoints, developer profile, ‚ÄúDeploy‚Äù or ‚ÄúBuy License‚Äù button) and each HyperBox (with detailed hardware specs, owner profile, reviews, ‚ÄúBook‚Äù or ‚ÄúDeploy here‚Äù action).
  - **Profile Dashboard:** for users to manage their listed AIMs/HyperBoxes, view deployments, and messages.
- **Security & Scaling Foundation:** From the start, choose patterns to scale:
  - Use environment-specific configuration for testnet vs mainnet (we will support Cardano and multiple EVM chains), toggled via env variables or runtime settings.
  - Plan to deploy the app on a scalable cloud service or container (e.g. Vercel for Next.js frontend, and a Node server on AWS/GCP or Heroku for backend API if needed). Use CDN for static assets and potentially for AIM metadata if large.
  - Outline basic security: input validation on API routes, HTTPS everywhere, Content Security Policy for the Next.js app (especially since it will load data from node addresses), and secure storage of any sensitive data.

*Rationale:* This foundational phase ensures we account for the unique aspects of the HyperCycle ecosystem in our design. For example, we know that **decentralized AI marketplaces will host various AI services** (translation, data analysis, image recognition, etc.) offered by AI agents ([HyperCycle's Answer to Security Risks in The Internet of AI Agents](https://coinpedia.org/information/hypercycles-answer-to-security-risks-in-the-internet-of-ai-agents/#:~:text=Marketplaces%20are%20decentralized%20platforms%20where,even%20if%20one%20node%20fails)), so our architecture must flexibly support different AIM types. We also anticipate interacting with **HyperCycle‚Äôs own blockchain token (HyPC)** for payments and possibly **node license tokens**, so we include blockchain modules from the start.

## Phase 2: AIM & HyperBox Listing Functionality

**Objectives:** Implement the core marketplace features for browsing and listing AIMs and HyperBoxes. This includes front-end pages to view listings and a basic backend to fetch/store listing data.

- **AIM Catalog:** Develop the AIM listing page and detail page.
  - Create a database table **AIMs** with fields: `id`, `name`, `description`, `developer_id (owner)`, `manifest_url` (or IPFS hash for AI module manifest/code), `license_type` (e.g. open, purchase-required), `price` (if license is sold), `required_specs` (JSON of min compute requirements like ‚ÄúGPU_RAM: 10GB, CUDA: true‚Äù, etc.), `created_at`.
  - Implement a Next.js page `/aims` to display all AIMs. Show each AIM‚Äôs name, short description, and perhaps an icon or image. If categories or tags exist (e.g. Vision, NLP, etc.), allow filtering by those.
  - The AIM detail page (`/aims/[id]`) should show full description, the developer‚Äôs profile name, possibly an **endpoints list** from the AIM‚Äôs manifest, and a ‚ÄúDeploy‚Äù or ‚ÄúBuy/License‚Äù button (we will implement functionality in later phases). If the AIM has an associated NFT or license requirement, indicate it in UI (e.g. ‚ÄúLicense required‚Äù badge).
  - **UX:** Keep AIM cards clean and informative. Use badges or icons for type of AI (e.g. üñºÔ∏è for image model, üîä for audio, etc.). On detail, if possible, display usage examples or an interactive demo (to be integrated once deployment works).
- **HyperBox Directory:** Develop pages for HyperBox listings.
  - Create **HyperBoxes** table with fields: `id`, `owner_id`, `name` (or location label like ‚ÄúJohn‚Äôs HyperBox‚Äù), `specs_cpu`, `specs_gpu`, `specs_ram`, `specs_storage`, `bandwidth`, `location` (could be country or region), `price_per_hour` (or per operation), `available` (boolean), `created_at`.
  - Provide a form or admin interface for a HyperBox owner to create a listing (for now, manual entry of specs; in Phase 4 we‚Äôll automate spec retrieval). Include fields for hardware specs and desired pricing.
  - Implement Next.js page `/hyperboxes` listing all available boxes. Show key specs (e.g. ‚Äú4 vCPU, NVIDIA A100, 40GB RAM, Location: US-West‚Äù) and price. Allow sorting/filtering, e.g. by GPU type or price. Users should be able to click a HyperBox to view more details.
  - HyperBox detail page (`/hyperboxes/[id]`) should show full specs (including GPU model, CPU model, memory, storage, network speed if provided), the owner‚Äôs profile (with contact button or link to messaging), pricing details, and a ‚ÄúBook/Deploy AIM here‚Äù action.
  - **Auto-matching Preview:** On the AIM detail page, as a convenience, list a few compatible HyperBoxes (ones that meet the AIM‚Äôs `required_specs`). This can be done by comparing the AIM‚Äôs required GPU/CPU with the HyperBox specs in our database. For example, if an AIM needs a GPU with CUDA and 8GB VRAM, filter HyperBoxes that have `specs_gpu_vram >= 8GB`. (Full auto-matching workflow will be refined in Phase 5‚Äì6.)
  - **UX:** Use visual indicators for HyperBox performance (e.g. a simple bar or rating for ‚ÄúCompute Power‚Äù based on CPU/GPU), and perhaps a green/red dot for availability. For filtering UI, provide checkboxes or sliders (e.g. min GPU memory, price range).
- **Data Fetching:** Implement API routes or server-side data fetching for these pages.
  - For `/aims` and `/hyperboxes`, Next.js can fetch from our database (via an ORM like Prisma or direct queries) and render the list server-side for SEO. Use pagination or lazy-loading if the list grows large.
  - No blockchain integration yet in this phase ‚Äì data is stored off-chain for now, which is acceptable because actual purchases or deployments haven‚Äôt been implemented. We will integrate the on-chain verification in later phases.
- **Testing:** Populate some sample AIMs (including one mock AIM from the `pyhypercycle-aim` repo for realism) and HyperBox entries to ensure the pages render correctly. Example: a mock ‚ÄúImage Generator AIM‚Äù requiring a GPU, and a ‚ÄúHyperBox Alpha‚Äù with an NVIDIA RTX 3080 GPU listed as available.

*Rationale:* By implementing basic listing capabilities early, we set up the marketplace structure. Users can start exploring what AIMs exist and what HyperBoxes are available. Even at this stage, the marketplace is useful as a **catalog of AI services and hardware providers**. We know that in HyperCycle‚Äôs vision, individuals with HyperBoxes (AI appliances) will provide computing power and earn inco ([Digital Investor x Hypercycle: "HyperAppliance" & ERC721?](https://defiance.media/video/digital-investor-x-hypercycle-hyperappliance-erc721/#:~:text=,potential%20energy%20and%20thermal%20energy))4„Äë, so it‚Äôs critical to present those offerings clearly. Similarly, AIM developers need a space to showcase their AI modules to potential users. The database design here will support later enhancements like searching by requirements or linking to blockchain assets. We‚Äôve kept the UI simple and focused on essential info (for instance, showing GPU resources which are vital since an AIM‚Äôs viability depends on GPU availability). We also lay groundwork for matching AIMs to suitable hardware by storing specs for both.

## Phase 3: Wallet Integration and User Accounts

**Objectives:** Enable users to connect their cryptocurrency wallets to the marketplace and establish a user profile linked to their on-chain identity. Support Web3 logins for EVM networks and Cardano via Mesh JS. This phase also introduces basic account management in the UI.

- **EVM Wallet Connection:** Integrate **Web3 wallet** login (MetaMask and WalletConnect). When a user clicks ‚ÄúConnect Wallet‚Äù, trigger the Web3 provider:
  - Use `ethers.js` (or `web3.js`) on the frontend to request connection to Ethereum-compatible wallets. Support Ethereum, Polygon, BNB Chain, and Base networks. We can allow network switching or detect the network the user is on. Initially, connect to whichever network (we will handle specific chain logic in transactions later).
  - Once connected, retrieve the user‚Äôs address. Optionally, prompt the user to sign a message to prove ownership (for added security on login).
  - On the backend (Next.js API), verify the signature (if used) and create or fetch a user record in the database associated with that address. For example, user table might have `eth_address` field. If a new user, create a profile entry (they can later add a username, etc.).
  - Store an authentication token (e.g. JWT or NextAuth session) tying the wallet address to the session so the user stays logged in. (Since this is a decentralized app, we might also choose not to use JWT and simply rely on the wallet signature each session, but that would require re-signing frequently. A short-lived session token after signature is a good middle ground.)
- **Cardano Wallet Connection:** Integrate **Mesh JS** (a popular Cardano web wallet library) to allow Cardano wallet connections (e.g. Nami, Eternl). Mesh provides UI components or APIs to connect to Cardano wallets and get an address and public key.
  - When a user selects ‚ÄúConnect Cardano Wallet‚Äù, use Mesh to connect and fetch their Cardano address. Similarly to EVM, have them sign a message with their Cardano key for verification if needed (Mesh can request a data signature).
  - Create/associate a user record with their Cardano address (e.g. store in `cardano_address` field).
  - **Multi-chain Profile:** Our **User** table should accommodate multiple addresses. We might have columns like `eth_address`, `cardano_address`, etc., or a separate table mapping user_ids to addresses of various chains. Ensure a single user can link both an EVM wallet and a Cardano wallet if they choose (especially if the same person participates on both networks).
- **Profile Management:** Implement a basic **Profile page** where logged-in users can add additional info: username/nickname, avatar image, bio, and link their other wallet if they have both types. This profile will be displayed in AIM listings (developer info) or HyperBox listings (owner info).
  - Add fields to User table for `username` (string), `bio`, etc. The username can be auto-populated in a friendly way (e.g. take first 6 chars of their address as default, like ‚Äú0xabc123‚Ä¶‚Äù) with option to edit.
  - Provide an edit form on the Profile page to update these fields. Keep personal data minimal ‚Äì since this is Web3, many users may remain pseudonymous.
- **Wallet-Based Actions Prep:** With wallet integration in place, mark certain actions in the UI as authenticated:
  - Only allow **creating a new AIM listing or HyperBox listing** if the user is logged in with a wallet. The UI should guide them (‚ÄúPlease connect your wallet to list an AIM/HyperBox‚Äù). This ties listings to on-chain identity (even though stored off-chain, we know which address is the owner).
  - Prepare for future on-chain transactions: e.g. for buying an AIM license or booking a HyperBox, the frontend will use the connected wallet. Ensure we have the providers (ethers, Mesh) accessible globally or via context in the app.
- **Testnet/Mainnet Toggle (preliminary):** In user settings or as a site-wide toggle, allow switching between **Testnet** and **Mainnet** modes. This can simply be an app-level state that changes which chain IDs or Cardano network (Preprod vs Mainnet) the wallet connectors use. In this phase, it‚Äôs mainly to ensure that when we test the integration, we can use testnets (Goerli, Polygon Mumbai, Cardano Preview, etc.). We‚Äôll refine this in Phase 9 when actually deploying contracts on testnet/mainnet.
- **UI/UX:** Clearly indicate the user‚Äôs wallet status. For example, show the shortened address or username in the nav bar when connected (and perhaps their profile avatar). Use chain-specific icons (Ethereum fox for MetaMask, Cardano logo for Cardano wallet) so users know which they have connected. If a user has both, show both statuses. For simplicity, we might treat them as separate login flows that both link to the same user profile if done by the same person.
- **Security:** When dealing with wallet connections, never store private keys ‚Äì use the provider. Use HTTPS and ensure our domain is recognized by MetaMask to avoid phishing warnings. If using JWT for session, secure it (HttpOnly cookie). Also, implement checks on the backend for any critical actions ‚Äì e.g. if a user calls an API route to list an AIM, verify the request is authenticated as that user. This prevents someone from spoofing another‚Äôs address in an API call.

*Rationale:* Wallet integration is crucial for a decentralized marketplace, as it forms the basis of identity and transaction capabilities. By supporting **EVM wallets and Cardano wallets**, we accommodate HyperCycle‚Äôs multi-blockchain approach (HyperCycle itself is related to Cardano sidechain tech, and assets like AGIX or NTX are on Cardano, whereas HyperCycle‚Äôs own token HyPC may initially be on Ethereum). Now users can sign in with their crypto identity instead of traditional accounts. This not only improves security (no passwords to hack) but also sets the stage for verifying ownership of AIM NFTs or HyperBox license tokens. For example, if HyperBox node licenses are represented by NFTs, linking the wallet will let us confirm the user holds the license tok ([Digital Investor x Hypercycle: "HyperAppliance" & ERC721?](https://defiance.media/video/digital-investor-x-hypercycle-hyperappliance-erc721/#:~:text=,alternative%20to%20traditional%20space%20heaters))3„Äë. Moreover, interacting with deployed AIMs will require signing transactions (as the HypC JS API suggests using MetaMask for signing tas ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=options%2C%20so%20you%20can%20specify,decoded%20task%20result))7„Äë), so the groundwork for that is laid here. The UX around wallet usage is kept simple and familiar (Connect button, show address), to reduce friction for crypto-savvy users.

## Phase 4: HyperBox Onboarding and Specification Retrieval

**Objectives:** Implement the backend flow and UI for HyperBox owners to **register (onboard) their HyperBox** into the marketplace. This includes verifying the HyperBox owner (via wallet), collecting hardware specs automatically, and allowing the owner to set pricing and availability. We reference the mock AIM (HyperBox ‚Äúscraper‚Äù AIM) and `pyhypercycle-aim` library to facilitate spec retrieval.

- **Owner Verification:** When a user wants to list a HyperBox, ensure they are logged in with their wallet. Use the wallet info to verify ownership:
  - If HyperCycle node licenses are NFTs (e.g. an ERC-721 token representing the right to run a node), check on-chain if the user‚Äôs wallet holds such a token. For instance, if HyperAppliance/HyperCycle issued ‚ÄúNode License‚Äù NFTs, call the contract to see if `balanceOf(userAddress) > 0`. This can be done via web3 on the backend or frontend. If the license token exists on Cardano (as mentioned in HyperCycle documents), use the Cardano wallet‚Äôs assets to verify similarly.
  - *Note:* Depending on how HyperCycle implemented licensing, this step may be optional. If no readily checkable license token, we rely on trust (user claims they have a HyperBox). But the roadmap anticipates license verification since HyperBoxes are sold with licens ([Digital Investor x Hypercycle: "HyperAppliance" & ERC721?](https://defiance.media/video/digital-investor-x-hypercycle-hyperappliance-erc721/#:~:text=,alternative%20to%20traditional%20space%20heaters))3„Äë.
  - The UI for onboarding can display a message like ‚ÄúNode License Verified ‚úÖ‚Äù if a valid token is detected, or a warning if not.
- **Spec Query via Scraper AIM:** To automate filling in HyperBox specs, leverage the **HyperBox Scraper AIM** (as hinted by `hyperbox-scraper` in HyperCycle‚Äôs tools). The HyperBox device likely runs a HyperCycle node which can host an AIM that reports hardware info.
  - Provide the HyperBox owner with instructions to ensure their machine is ready: e.g. ‚ÄúPlease run your HyperCycle node and deploy the system scraper AIM to gather specs.‚Äù This could be as simple as running a docker command on their HyperBox (for example, a Docker image `hypercycle/hyperbox-scraper`).
  - Once the scraper AIM is running on the HyperBox (perhaps on a known port or accessible via the node‚Äôs API), our marketplace backend can query it. For instance, call `GET http://<hyperbox_ip>:4000/specs` or use the HypC JS client to call a method of the scraper AIM.
  - The data returned might include CPU model/count, GPU model (and memory), total RAM, internet bandwidth, current uptime, etc. Parse this and pre-fill the HyperBox listing form for the user.
  - If direct connection isn‚Äôt possible (maybe the HyperBox is behind NAT), we can fall back to manual entry, but the automated approach improves accuracy. Another approach is to use the `pyhypercycle-aim` library on the HyperBox to print specs to console and have user paste it ‚Äì but direct querying is preferable.
  - **Database:** Extend the HyperBoxes table to store detailed specs (could use a JSON field for flexibility). Also store a field for `wallet_address` of the owner (so we know which on-chain identity is tied to it).
- **Onboarding Form:** Build a wizard or form in the UI:
  1. Step 1: Connect wallet (already done in Phase 3).
  2. Step 2: ‚ÄúVerify HyperBox‚Äù ‚Äì possibly prompt the user to input the IP/domain of their HyperBox or some identifier so we can query it. Alternatively, if the user‚Äôs browser is on the same network, we might attempt a local discovery ‚Äì but likely simplest is asking for an IP or letting them run a script that calls our backend.
  3. Step 3: After entering connection info, hit a Next.js API route like `/api/hyperbox/fetch-specs` which attempts to call the scraper AIM on that address. If successful, show the retrieved specs to the user for confirmation (list CPU, GPU, etc.).
  4. Step 4: The user sets their pricing and availability. For pricing, allow a rate per hour or a flat fee per deployment. Also allow them to set a **preferred payment token** (maybe HYPC by default, or other tokens, but since actual usage is paid via HyPC microtransactions, this might just be informative). If they want to offer fixed rental (outside of per-task payments), this pricing would apply.
  5. Step 5: Submit ‚Äì this saves the HyperBox entry in the database with status ‚Äúlisted‚Äù. Optionally, we could mint an NFT on-chain representing this listing (not strictly needed, but could be useful for discovery on-chain ‚Äì out of scope for now).
- **Smart Contract Tie-in (optional):** If the project uses on-chain registration of nodes (HyperCycle might have a **NodeRegistry** contract or similar), consider integrating that:
  - For example, after listing in our DB, also call a contract function to register the node (passing the specs or a reference). This would allow on-chain tracking of available HyperBoxes. Given that HyperCycle is ledgerless but could use sidechain, this might not exist yet ‚Äì so we mark it optional. The focus remains on off-chain coordination with on-chain identity verification.
- **UX & Feedback:** After submission, the owner should see their HyperBox in their profile (under ‚ÄúMy HyperBoxes‚Äù) with an indication it‚Äôs active. Provide a way to update specs (in case they upgrade hardware) or toggle availability (if they shut down the node for maintenance).
  - Also, as a trust signal, show a ‚ÄúVerified‚Äù label if the specs were auto-fetched. Users browsing HyperBoxes will appreciate knowing the data is genuine. (We could even display ‚ÄúLast verified on 2025-04-10 via HyperCycle node‚Äù).
  - The **HyperBox detail page** for others can show a badge if the owner has the license NFT (since that implies legitimacy). And show the owner‚Äôs wallet (masked) or username.
- **Example:** Alice owns a HyperAI Box device. She connects her Ethereum wallet which holds a HyperCycle Node License NFT. The marketplace verifies it on-chain and auto-fetches her device‚Äôs specs using the scraper AIM. It finds ‚Äú8-core CPU, NVIDIA A100 (40GB), 128GB RAM‚Äù. Alice sets $5/hour as her price. She submits, and now her HyperBox ‚ÄúAlice‚Äôs AI Box ‚Äì US West‚Äù appears for everyone with those specs  ([HyperCycling Towards Superintelligence: Revolutionizing AI and Decentralized Networks | by SingularityNET Ambassadors | Medium](https://medium.com/@singularitynetambassadors/hypercycling-towards-superintelligence-revolutionizing-ai-and-decentralized-networks-8d04e3cac0bc#:~:text=The%20HyperAIBoxes%20come%20with%20pre,your%20computing%20power%20even%20more)) ([Digital Investor x Hypercycle: "HyperAppliance" & ERC721?](https://defiance.media/video/digital-investor-x-hypercycle-hyperappliance-erc721/#:~:text=,alternative%20to%20traditional%20space%20heaters))3„Äë**.

*Rationale:* This phase streamlines the process for HyperBox owners to join the marketplace. Given HyperCycle‚Äôs goal of **plug-and-play AI appliances that anyone can operate ([HyperCycling Towards Superintelligence: Revolutionizing AI and Decentralized Networks | by SingularityNET Ambassadors | Medium](https://medium.com/@singularitynetambassadors/hypercycling-towards-superintelligence-revolutionizing-ai-and-decentralized-networks-8d04e3cac0bc#:~:text=The%20HyperAIBoxes%20come%20with%20pre,your%20computing%20power%20even%20more))4„Äë, we want the onboarding to be as simple as ‚Äúconnect your wallet, attach your license, and you‚Äôre online‚Äù ‚Äì exactly as the HyperCycle team envisions (the HyperAIBox requires just plugging in, wallet, and license to start providing compu ([HyperCycling Towards Superintelligence: Revolutionizing AI and Decentralized Networks | by SingularityNET Ambassadors | Medium](https://medium.com/@singularitynetambassadors/hypercycling-towards-superintelligence-revolutionizing-ai-and-decentralized-networks-8d04e3cac0bc#:~:text=The%20HyperAIBoxes%20come%20with%20pre,your%20computing%20power%20even%20more))4„Äë). By using an automated Scraper AIM (as indicated in HyperCycle‚Äôs tools), we minimize manual errors and ensure that when someone lists a HyperBox, the specs are accurate and trustworthy. Verifying the wallet and license token ensures the lister truly owns a HyperBox (preventing fake listings). For pricing, giving owners control lets a market economy form. We anticipate that, for example, a HyperBox with a powerful GPU could command a higher price. Security-wise, querying the HyperBox‚Äôs AIM could pose risks (e.g. if an attacker pretends to be a HyperBox). To mitigate, require the owner to sign the data or the query with their wallet (maybe the scraper AIM can return a signed payload using the node‚Äôs key). These nuances can be handled by adding a secret token or confirming via the wallet that the node responded, but such complexity might be refined later. At this stage, a basic check plus the fact that the owner had to connect their wallet (so a malicious user would have to also have the license NFT) provides reasonable assurance of valid listings.

## Phase 5: AIM Publishing and Smart Contract Integration

**Objectives:** Allow AI developers to publish (list) their AIMs on the marketplace with proper metadata and integrate smart contracts for AIM licensing or ownership transfers. This phase connects the off-chain AIM listings with on-chain assets (e.g. NFTs) to enable **buying and selling of AIMs or their usage rights**.

- **AIM Manifest & Metadata:** When a developer wants to list a new AIM, gather detailed info:
  - Leverage the structure from the `pyhypercycle-aim` library to guide what info to collect. For example, an AIM built with `pyhypercycle-aim` likely has a manifest that includes the **endpoints** it exposes, expected **input/output formats**, and possibly a version and license info.
  - Provide a form (or ideally, an upload) for the developer to submit their AIM:
    - **AIM Name, Description, Category:** Basic info for discovery.
    - **Container Image or Code Upload:** The developer can supply a Docker image name (if they‚Äôve containerized the AIM) or upload code (which we could containerize or store ‚Äì but storing a large model on-chain is impractical, so likely they provide a Docker image hosted on a registry or an IPFS hash to build the image).
    - **Manifest URL/JSON:** Optionally, allow them to provide a link or text for the AIM‚Äôs manifest file (listing its endpoints and hardware requirements). If not, we might generate it by asking them to fill in endpoints and requirements manually in the form.
    - **Hardware Requirements:** Ask what the AIM needs at minimum (e.g. ‚ÄúRequires GPU with 8GB VRAM and CUDA,‚Äù or ‚ÄúNeeds 4GB RAM, no GPU‚Äù). This maps to HyperBox specs and will be stored in `required_specs`. (We can later use this to auto-match to HyperBoxes that meet or exceed these specs).
    - **Licensing & Pricing:** The crucial part ‚Äì decide how this AIM is offered:
       - *Free or Open-Source:* Developer might allow anyone to deploy/use it freely (perhaps they just want usage or have another monetization).
       - *One-time Purchase (NFT license):* Developer sells it as an NFT ‚Äì whoever buys the NFT can deploy the AIM (like buying software license). They could allow multiple copies via multiple NFTs (like an ERC-1155 ‚ÄúAIM License Token‚Äù with limited supply), or a single NFT for exclusive ownership.
       - *Pay-per-use:* Developer might not sell the code, but charges per API call. HyperCycle‚Äôs native approach uses HyPC tokens per call (micropayments) to reward node operators *and* could potentially reward the AIM author. However, in the HypC model, it seems the node gets paid by the user direct ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=options%2C%20so%20you%20can%20specify,decoded%20task%20result))7„Äë. To ensure the developer also benefits, we can incorporate a fee or have them set a per-call price that includes a margin for them (this is complex and might be handled by the HyperCycle protocol itself eventually).
    - For simplicity, implement at least **one licensing model** now: e.g. *AIM as NFT.* The developer sets a price (in crypto) for the AIM, and an NFT is minted to represent ownership/license. Owning the NFT grants the right to deploy that AIM.
  - **Smart Contract for AIM:** If not already existing, deploy a simple ERC-721 contract (or use an existing marketplace contract) for AIM licenses. Each AIM could correspond to a unique token (token metadata can include the AIM name/description and perhaps a pointer to the manifest or image). Alternatively, deploy one contract for all AIMs, where each token ID is an AIM. The contract should store at least a reference (like an IPFS hash) to the AIM‚Äôs code or manifest.
  - When a developer lists an AIM for sale:
    - Our backend (or a contract call from the user) mints a new NFT representing that AIM to the developer‚Äôs address. We set the token URI to the AIM‚Äôs metadata (this could include a link to the code archive or container).
    - The NFT could be listed for sale on-chain (via a marketplace contract or by the developer offering it to others).
    - If using a direct sale approach: upon minting, immediately create a sell order (perhaps our marketplace contract has a function like `listAIM(tokenId, price)` which escrows the NFT and sets a price).
    - If we want to avoid writing a whole on-chain marketplace, a simpler method: when a buyer clicks ‚ÄúBuy AIM for X‚Äù, just invoke a safe transfer of the NFT from seller to buyer in exchange for crypto. This can be two transactions (one ERC-20 or native token transfer for payment, one NFT transfer) ‚Äì which can be handled via our UI and a bit of trust that the user follows through. A proper escrow smart contract is safer (to avoid one side failing), but that can be implemented if time permits.
- **Buying an AIM:** Implement the frontend flow for a user to buy an AIM:
  - On the AIM detail page, if it‚Äôs listed for sale and not owned by the viewer, show ‚ÄúBuy for X [token]‚Äù. When clicked, prompt the user‚Äôs wallet to execute the purchase. For an ERC-721 on Ethereum:
    - If using a marketplace contract, call `buyAIM(tokenId)` which internally transfers the NFT to buyer and sends payment to seller (minus any fees).
    - Or if using direct method, instruct user to send payment (perhaps in stablecoin or ETH) to the seller‚Äôs address, then after detecting payment (this would need off-chain check or trust), call `transferFrom` to give them the NFT. (Better to use a contract to avoid race conditions).
  - If purchase succeeds, update the AIM‚Äôs status in our DB (mark as owned by new user, or mark as not for sale if it was one-off).
  - If the AIM is free or doesn‚Äôt require license, simply mark it as accessible to all (no purchase needed).
- **Deploying AIM to HyperBox (License enforcement):** Before actual deployment (Phase 6), enforce that a user has rights to an AIM:
  - If an AIM is free, anyone can deploy it on any HyperBox (subject to resource match).
  - If an AIM requires a license NFT, ensure that the user who attempts deployment owns that NFT in their wallet. We will check this in Phase 6 when deployment is requested. (This is where our earlier wallet integration pays off ‚Äì we can easily check their connected wallet for the token).
  - The AIM‚Äôs manifest (from fetchManifest) might also encode license in ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=,requirements%20and%20the%20AIM%20license))9„Äë ‚Äì possibly the AIM itself might verify a license token presence when running. For example, the manifest/license could require that the caller‚Äôs address holds the NFT. We should mirror that logic: **the marketplace should not allow ‚ÄúDeploy‚Äù unless license conditions are met**, to prevent wasting time attempting unauthorized runs.
- **Database Updates:** Expand the AIM table:
  - Add `token_contract` and `token_id` fields to link an AIM listing to its NFT (if minted).
  - Add `status` (e.g. ‚Äúavailable‚Äù, ‚Äúsold‚Äù, ‚Äúopen‚Äù). If an AIM can be sold multiple times (like 100 licenses), we might have a separate table for AIM licenses or simply handle that on-chain without reflecting in DB for each buyer.
  - Add `owner_id` or link to the current owner (which could differ from the original developer if sold).
  - Add `price` and `currency` for sale info (and possibly `is_listed_for_sale` boolean).
- **Smart Contract Integration Details:**
  - Use the **HyperCycle contracts repo** for any existing standards. If the repo `contracts` has something like an AIM contract, use that. (If none, proceed with our own minimal ERC-721).
  - Ensure our contract can work on both EVM and maybe Cardano. Realistically, NFT for Cardano would be a different flow (minting native asset via Cardano transaction). Given complexity, we might focus on EVM for NFT licensing, and later support Cardano by perhaps mirroring the asset or just marking that an AIM is also published on Cardano marketplaces. (This could be future work; for now assume EVM for this part).
  - On the UI, use `ethers.js` to call contract methods. Provide user feedback for transactions (pending, confirmed). Use testnets now (e.g. mint on Goerli) to test the end-to-end.
- **Example scenario:** Bob (developer) wants to monetize his ‚ÄúChatbot AIM‚Äù. He uses the marketplace to publish it. He sets it to require a license NFT priced at 100 MATIC. The system mints an NFT for ‚ÄúChatbot AIM v1‚Äù to Bob. Alice wants to use that AIM, so she buys the NFT from Bob via the marketplace (paying 100 MATIC). Now Alice‚Äôs wallet holds the ‚ÄúChatbot AIM‚Äù NFT. When Alice goes to deploy the AIM on a HyperBox, the system will see she owns the NFT and proceed, whereas other users without it would be blocked. The AIM‚Äôs manifest also knows about the license, so the HyperCycle node could double-check license at runti ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=,requirements%20and%20the%20AIM%20license))5„Äë.

*Rationale:* This phase brings actual economic activity to the marketplace ‚Äì **AIM developers can earn by selling or licensing their modules, and users can acquire new AI capabilities.** The use of NFTs aligns with the decentralized nature: an AIM license as an NFT can be resold or transferred by the owner, enabling a secondary market and giving owners property rights over the AI module (similar to owning a copy of software). The inclusion of smart contracts is guided by hints in the ecosystem: HyperAppliance mentions **ERC-721 devices and profit distribution ([Digital Investor x Hypercycle: "HyperAppliance" & ERC721?](https://defiance.media/video/digital-investor-x-hypercycle-hyperappliance-erc721/#:~:text=,also%20creating%20a%20profitable%20ecosystem))3„Äë, showing that NFTs are indeed part of the design for sharing value. Also, the HypC JS API‚Äôs notion of an AIM license in the manife ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=,requirements%20and%20the%20AIM%20license))9„Äë suggests that an AIM might not run unless license conditions are met ‚Äì implementing NFTs for license is a logical way to enforce that off-chain and on-chain. By Phase 5‚Äôs end, the marketplace is not just a directory, but a functional dApp where digital assets (AIMs) are exchanged. We take care to integrate the blockchain piece securely: contract calls should be thoroughly tested on testnet to avoid bugs when dealing with real funds, and the UI warns users to use the correct network (prevent confusion of where the NFT exists). We also ensure that free/open AIMs are supported to encourage community contributions (not everything must be monetized). 

## Phase 6: Deployment of AIMs to HyperBoxes (Compute Provisioning)

**Objectives:** Enable users to deploy an AIM onto a chosen HyperBox. This is the core functionality that brings together the AIM, the HyperBox, and the user‚Äôs session. We will create a workflow to allocate the HyperBox for the AIM and initiate the deployment via a ‚Äúdeployment API layer‚Äù (potentially the component nicknamed **Barry** in the HyperCycle ecosystem). This phase also involves scheduling and ensuring the HyperBox is booked for the user‚Äôs AIM.

- **Matchmaking Confirmation:** When a user clicks ‚ÄúDeploy on HyperBox‚Äù for a given AIM:
  - If the user has chosen a specific HyperBox (manual selection), use that. If they opted for auto-match, at this moment pick the best available HyperBox that meets the requirements (filter by specs, then perhaps by lowest price or lowest latency if we have location info).
  - Check availability: ensure the HyperBox isn‚Äôt currently at capacity or booked. For now, assume each HyperBox can run multiple AIMs up to its resource limits ‚Äì but we might restrict to one heavy job at a time to simplify. We have an `available` flag in DB; we might also implement a basic scheduler that marks it busy during deployment.
  - Create a **Deployment record** in the DB with status ‚Äúpending‚Äù for this AIM-HyperBox-user triad.
  - Enforce AIM license: verify the user has the rights (as decided in Phase 5). If not, abort and show error (‚ÄúYou do not own the license for this AIM‚Äù or ‚ÄúPurchase required‚Äù).
  - Payment handling: If the HyperBox usage is not free, we might at this point handle payment. There are two models:
    1. **Prepaid booking:** Charge the user for, say, 1 hour of usage upfront. This could be done via a blockchain transaction to the HyperBox owner‚Äôs address or a marketplace escrow. For simplicity, we could skip upfront payment and rely on the micropayment per call (especially if the AIM itself will charge per use). However, for long-running jobs or exclusive booking, upfront makes sense.
    2. We decide that for now, **no upfront payment** ‚Äì instead, the user will pay per AI call (via HyPC tokens) and the HyperBox owner earns from that. This aligns with the HyperCycle microtransaction model where each task execution triggers a token payment to the no ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=options%2C%20so%20you%20can%20specify,decoded%20task%20result))7„Äë. We will assume that mechanism covers the compute cost. (In future, we could allow owners to set a base fee).
  - If we do want to support a booking fee: integrate a small on-chain payment here (e.g. user pays in HyPC or stablecoin, and we mark the HyperBox reserved for X time).
- **Deployment Orchestration (Barry):** Invoke the mechanism to actually deploy the AIM on the HyperBox. We have a few options:
  - The HyperCycle node (running on the HyperBox) likely has an API or daemon listening for deployment commands (this could be what internally the team calls ‚ÄúBarry‚Äù ‚Äì possibly a deployment orchestrator service). We should research if `hypc-js` or `pyhypercycle-aim` provides a way to deploy an image to a node. If not directly exposed, we might need to run a script over SSH or use a remote procedure.
  - A plausible approach: Use Barry‚Äôs deployment API ‚Äì for example, a REST call like `POST http://<hyperbox_ip>/deploy` with the image name or manifest of the AIM. If the HyperBox owner has something like Barry‚Äôs agent running, it would pull the Docker image for the AIM and start the container within the node environment, registering it as an available AIM on that node.
  - If direct deployment isn‚Äôt open (for security, maybe owners want to approve), we can send a **notification to the owner** (e.g. via the messaging system or email) saying ‚ÄúUser X wants to deploy AIM Y on your HyperBox. Approve?‚Äù The owner could then run a provided command. But that introduces delay and friction. Ideally, owners opt-in to automatic deployments by listing themselves ‚Äì meaning they are okay with the marketplace remotely deploying jobs in exchange for payment.
  - We will proceed assuming automatic deployment is allowed under an agreed protocol. This likely involves authenticating our request ‚Äì maybe signing it with the user‚Äôs key or the marketplace‚Äôs key that the HyperBox trusts. The HyperBox could verify that the request comes with a valid signature of the AIM license holder, etc.
  - **Integration with HypC Node:** If possible, use the HypC JavaScript API on the backend to communicate with the node. Hypc-js might not explicitly have a deploy function in the snippet we saw, but it does allow calling internal fetch functio ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=))4„Äë. In absence of a formal API, we might exec a remote CLI. Since `pyhypercycle-aim` exists, maybe there‚Äôs a CLI to launch an AIM given a Docker image on a node.
  - Implement a module (called e.g. `deploymentService`) that takes `aim` and `hyperbox` info and carries out the deployment. This could be:
    1. Pull the AIM container image to the HyperBox (if not already present). Perhaps the HyperBox‚Äôs node can pull from Docker Hub or IPFS. We might need to provide image credentials if private.
    2. Start the AIM container within the HyperCycle node environment. (The node might handle network and exposing endpoints).
    3. Register the AIM‚Äôs endpoints so they are callable. HypC nodes likely auto-register AIM endpoints once running.
    4. Confirm deployment by calling `client.aims()` on that node and checking the AIM appears in the li ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=))5„Äë. The `info` of the AIM on the node can be retrieved to ensure it‚Äôs running (we expect to see its name, image ID, status = running, and allocated GPU if a ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=,current%20status%20and%20GPU%20resources))5„Äë).
  - If deployment fails (e.g. due to image not found or insufficient resources), handle that: update DB status to ‚Äúfailed‚Äù and inform the user. Possibly suggest another HyperBox if available.
  - If deployment succeeds, update the Deployment record: status ‚Äúrunning‚Äù, store perhaps a `node_endpoint_url` (the base URL of the node where the AIM is now accessible) and maybe an `aim_instance_id` or name.
- **Resource Allocation & Duration:** Determine how long the AIM stays deployed:
  - For interactive services (like a chatbot), the user might want it running continuously until they stop. For one-off jobs, it might auto-terminate after completing a task. In our case, since we plan to let the user interact via UI, we likely keep it running until the user clicks ‚ÄúStop‚Äù or a time limit.
  - Implement a simple control: the user‚Äôs session or profile shows active deployments, and they can ‚Äúundeploy‚Äù or release the HyperBox when done. Also, the HyperBox owner should be able to force stop if needed (via their profile or if the marketplace detects inactivity).
  - For now, assume a deployment is on-demand and lasts for a ‚Äúsession‚Äù. We won‚Äôt implement complex scheduling or pre-booking beyond marking it busy.
- **UI Updates:**
  - After clicking deploy and getting confirmation, redirect the user to an **AIM runtime interface** (Phase 7) where they can use the AIM. In parallel, show a notification like ‚ÄúDeploying AIM to HyperBox...‚Äù, and then ‚ÄúDeployment successful on HyperBox X!‚Äù.
  - In the HyperBox detail page, if an AIM is running on it (especially if exclusively occupying it), we can show ‚ÄúCurrently in use‚Äù or reduce its availability.
  - On the user‚Äôs profile, list active deployments: e.g. ‚ÄúChatbot AIM running on Alice‚Äôs HyperBox ‚Äì [Stop]‚Äù.
- **Smart Contract (if any) for Deployment:** If the marketplace or HyperCycle network requires registering this usage on-chain (maybe not, but imagine a scenario where the HyperBox owner‚Äôs node might want to log the job for reputation or future rewards), we could call a contract or a HyperCycle API to log the event ‚ÄúAIM X deployed on Node Y at time Z‚Äù. This might be something like a usage record for later settlements. This is speculative; for now, we skip on-chain logging due to time.
- **Testing:** Try deploying a **mock AIM** (like a simple echo service from the `pyhypercycle-aim` examples) on a local HyperBox (we could simulate a HyperBox by running a HyperCycle node in a Docker on a test server). Use our system to deploy and ensure the AIM is reachable. This test is complex, but critical to iron out integration issues between our marketplace and the HyperCycle node environment.

*Rationale:* This is the heart of the marketplace‚Äôs functionality ‚Äì it turns the platform into a **bridge between AI module providers and distributed compute providers.** By successfully deploying an AIM on a HyperBox, we demonstrate the ‚ÄúUber for AI‚Äù concept: a user‚Äôs request (AIM to run) is matched with a driver (HyperBox to run it) and the service begins. We took cues from how cloud platforms deploy containers on demand, adapting it to our decentralized context. The mention of ‚Äúvia Barry or a deployment API layer‚Äù indicates the HyperCycle team has an internal service to manage such deployments, likely ensuring the right Docker image is fetched and run on the node. We align with that by designing our system to either call that service or mimic its function. We also align with **HyperCycle‚Äôs payment model**, where tasks are paid in microtransactions of HyPC toke ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=options%2C%20so%20you%20can%20specify,decoded%20task%20result))7„Äë. By not charging upfront in this design, we rely on that model: when the user uses the AIM (next phase), those calls will send HyPC tokens to the HyperBox node (and possibly a portion to the AIM creator if the system supports it). This keeps us in line with the idea that *computation is directly monetized at the node level* rather than fixed rental, which was a problem in centralized cloud (charging per second is more efficient than hourly, etc.). Still, our design is flexible to allow flat rental if needed later. From a security perspective, deploying code on someone‚Äôs machine has risks ‚Äì we mitigate by ensuring the code comes from the AIM developer (we have the image hash and license) and presumably HyperBox owners accept that risk to earn money. Isolation is handled by containers on the node. We must ensure the deployment channel is secure: the HyperBox should verify the request authenticity (perhaps using the license NFT or a pre-shared secret). Using TLS for the API call and requiring the owner to have set a token in our system (like when they onboard, generate an API key) can help secure the remote deployment endpoint. These details can be configured during the HyperBox onboarding (Phase 4) ‚Äì e.g., show the owner a one-time token that our system will use to deploy tasks on their box.

## Phase 7: User Interaction with Deployed AIMs (UI Proxy and Execution)

**Objectives:** Provide a **front-end interface for users to interact with AIMs** that have been deployed, and set up a proxy or direct connection to facilitate API calls to the AIM. This phase focuses on the runtime experience: executing AIM endpoints, showing results, and handling payment token flows for each invocation.

- **Custom UI Embedding:** Depending on the AIM‚Äôs nature, the interaction UI may vary:
  - For a chatbot AIM, the UI should be a chat window where the user enters messages and receives responses.
  - For an image generation AIM, the UI might be a form with a prompt text field and a ‚ÄúGenerate‚Äù button, then an image display.
  - For a data analysis AIM, perhaps file upload and result download.
  - We can‚Äôt custom-build a UI for every possible AIM, but we can support common patterns. Use the AIM‚Äôs manifest to decide:
    - If the manifest lists endpoints like `/chat` or a certain standardized interface (maybe the AIM‚Äôs metadata says `type: "conversation"`), load a corresponding UI component.
    - For simplicity, implement two generic UIs:
      1. **REST API Console:** A generic form where the user picks an endpoint from a dropdown (populated from manifest), enters JSON data or parameters, and sees JSON output. This is a fallback for advanced users or uncommon AIMs.
      2. **Prebuilt UI templates:** For known categories (chat, image gen, audio). We can identify these by convention (e.g. an endpoint named ‚Äú/generateImage‚Äù -> use image UI; an endpoint that outputs audio -> provide audio player).
  - The marketplace could allow AIM developers to provide a frontend component URL or script, but that raises security issues and complexity. Instead, we will maintain control by our own templates.
- **Proxy Server:** To call the AIM‚Äôs endpoints, we have two options:
  1. **Direct client-side calls:** The browser calls the HyperBox‚Äôs node API directly (e.g. `https://<node_address>/aims/<aimName>/<endpoint>`). However, this might be cross-origin. Unless the node sets CORS headers to allow our domain, the browser will block it. Also, the node might use self-signed certs or IP addresses, causing HTTPS issues. 
  2. **Proxy via Next.js API:** Safer approach is to have our backend proxy the requests. We create an API route like `/api/aimcall` that takes parameters (hyperbox id, aim id, endpoint, data). The server then makes the HTTP request to the HyperBox‚Äôs AIM endpoint (the HyperBox‚Äôs address we stored in deployment record) and returns the response to the frontend.
  
  We implement the proxy approach for reliability:
  - It hides the HyperBox address from the client (which could be considered sensitive or just simplify networking).
  - We can also inject the user‚Äôs auth token if needed. For example, HypC tasks require a **nonce signature** with MetaMa ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=options%2C%20so%20you%20can%20specify,decoded%20task%20result))7„Äë. This implies that before each call, the user‚Äôs wallet must sign a nonce to authorize the token payment. Hypc-js likely handles this by prompting MetaMask and including the signature in the request header.
  - If we do proxy, we need a way to still trigger wallet signing on the client. One way: use hypc-js on the frontend to prepare the request (which will do the signature and perhaps even send the request directly). Another way: the backend could challenge the client for a signature.
  - Simpler: include the hypc-js library on the frontend for the interaction page. That library can connect to the node and call `fetchEstimate` and `fetchResult` on the AIM interface directly from the brows ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=options%2C%20so%20you%20can%20specify,decoded%20task%20result))1„Äë. Because hypc-js uses MetaMask, it can sign and send through MetaMask‚Äôs provider, possibly bypassing CORS by using wallet injection or some web3 transport. If that works, it might not even need our proxy (the library might connect via its own channels or through the wallet).
  - We should test hypc-js in a browser context; if it can‚Äôt bypass CORS, we might still need to do the signing in JS and then send via our backend.
  - In any case, ensure the user is prompted to allow the transaction (sending HyPC tokens) when they use the AIM. For example, when they click ‚ÄúAsk‚Äù in chatbot, behind the scenes `fetchResult` will trigger a MetaMask confirmation to spend a tiny amount of HyPC tokens to the node (covering the computation cos ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=options%2C%20so%20you%20can%20specify,decoded%20task%20result))7„Äë.
- **Display Results:** Once the call returns, present the output nicely:
  - If it‚Äôs text (chatbot answer), append to chat.
  - If it‚Äôs an image (perhaps returned as URL or base64), show the image.
  - If it‚Äôs audio, provide a play button (and possibly a download link).
  - If JSON or structured data, show it in a formatted block or allow download if large.
  - Manage loading states for UX (spinner while waiting for response).
- **Error Handling:** If the AIM invocation fails (e.g. due to an exception in the AI code or a node issue), capture the error message and show it to the user in a friendly way. Also log it for dev/owner to debug later.
- **Payment Flow:** Because each `fetchResult` call involves token transfer, integrate balance display:
  - Show the user‚Äôs HyPC token balance in the UI (we can fetch via `client.fetchBalance( ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=))7„Äë). If low, prompt them to top-up (which might mean buying HyPC or bridging it ‚Äì outside our scope, but at least inform).
  - Possibly show the cost of a query by calling `fetchEstimate` before `fetchResult`. For instance, when user enters input, we call estimate and display ‚ÄúThis query will cost ~0.0023 HYP ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=,estimated%20cost%20for%20the%20task))4„Äë. Then user confirms and we call fetchResult to actually execute and pay.
  - Ensure the MetaMask or wallet prompt clearly indicates the tiny payment, so user isn‚Äôt alarmed.
- **Session Termination:** Provide a way to stop the AIM when done:
  - A ‚ÄúEnd Session‚Äù or ‚ÄúUndeploy‚Äù button that will trigger the HyperBox to stop the AIM container (and free resources). This would call our backend to instruct the HyperBox to shut down that AIM. Update deployment record to ‚Äúcompleted‚Äù with end time.
  - If the user just leaves without stopping, we might implement a timeout: e.g. if no interaction for 30 minutes, auto-stop the AIM. This is to not hog the HyperBox indefinitely. We can use a background worker or cron to check active deployments and their last activity timestamp (we update that on each proxy call).
- **UI Polishing:** The interaction page should seamlessly integrate into the marketplace UI but perhaps go fullscreen for focus:
  - E.g. `Chatbot AIM - Running on Alice's HyperBox` title, then the chat window. Show somewhere the HyperBox info and maybe a ‚ÄúPowered by [HyperBox Owner Name]‚Äù as a nod to the provider, along with a small link for tipping or rating (optional nice touch).
  - Provide feedback mechanism: user can rate the AIM‚Äôs quality and the HyperBox performance after using. This can be as simple as a 5-star rating stored in DB for each, contributing to profile reputation. (Security: one could spam ratings, but we can restrict to only if they actually deployed).
- **Security Considerations:**
  - The proxy must sanitize any data passed to prevent injection attacks on our backend when it makes requests. Use a allow-list of URLs (only the specific HyperBox URL we expect).
  - The user‚Äôs data going to the AIM might be sensitive, ensure it travels encrypted (HTTPS to HyperBox ‚Äì if HyperBox is running on a home connection, maybe it uses a certificate via something like Ngrok or our marketplace could provide a proxy address. If not possible, at least our API to it should use HTTPS when possible).
  - The interactions with wallets should be over secure contexts. We should double-check that calling MetaMask for signing multiple times quickly (like each message) is user-friendly. Perhaps MetaMask might allow pre-approving a certain spend (like an allowance of HyPC). If so, we could set an allowance so that every call doesn‚Äôt pop up a confirm, only the first one. This would use an ERC-20 approval if HyPC is ERC-20. Alternatively, the HypC token might require each spend to be signed (since it‚Äôs maybe layer-2).
  - Also consider the possibility of **malicious AIM code** returning something like a huge response or triggering client-side issues. Because we treat it mostly as data, and our UI controls the rendering, this risk is mitigated (e.g. we won‚Äôt eval any code from the AIM, just display text or images). Still, caution with any HTML in responses (escape any HTML to avoid injection).
- **Example:** Continuing Alice‚Äôs Chatbot example ‚Äì Alice now goes to the Chatbot AIM page and selects Bob‚Äôs HyperBox to deploy on (maybe Bob‚Äôs has a GPU needed). The marketplace deploys it; Alice is taken to a chat interface. She asks a question; behind the scenes the system calls `fetchEstimate` (gets cost ~0.001 HYPC) and then `fetchResult` on Bob‚Äôs node. MetaMask pops up asking to sign a microtransaction; Alice approves. The question goes through, Bob‚Äôs HyperBox processes it, and the answer comes back, which Alice sees appear in the chat. After a few Q&A, Alice clicks ‚ÄúEnd Session‚Äù, which triggers the node to stop the Chatbot AIM. The HyPC microtransactions have automatically gone to Bob‚Äôs node for each query (so Bob earned for providing compute), and possibly a portion to the AIM‚Äôs creator if that‚Äôs configured in the AIM (not handled by our app, but HyperCycle might handle rev-share internally). All of this happened seamlessly through our UI  ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=options%2C%20so%20you%20can%20specify,decoded%20task%20result)) ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=,current%20status%20and%20GPU%20resources))5„Äë**.

*Rationale:* Providing a smooth user experience for interacting with AI is what will make this marketplace actually useful. The user doesn‚Äôt need to know anything about the HyperBox or how the AIM is running; they just use a web interface and get results, like any cloud AI service, except it‚Äôs decentralized in the backend. By implementing the proxy and UI logic, we hide the complexity of signing transactions and calling distributed nodes. The reference to *‚Äúcustom UI proxy embedded within the marketplace‚Äù* is fulfilled by our proxy approach and tailored UI components. We ensure that even though the AI service is running on a peer-to-peer node, the user experience is as if it were a unified app. 

Importantly, this phase also **closes the loop on payments and security**: each AI call is authorized via the user‚Äôs wallet (no free riding), and the HyperBox owner gets their due automatically. The design leverages HyperCycle‚Äôs strength of microtransactions (solving the micropayment problem where centralized APIs would be too costly for tiny paymen ([HyperCycle's Answer to Security Risks in The Internet of AI Agents](https://coinpedia.org/information/hypercycles-answer-to-security-risks-in-the-internet-of-ai-agents/#:~:text=Apart%20from%20intermediaries%20introducing%20vulnerabilities,making%20micropayments%20prohibitive%20and%20unfeasible)) ([HyperCycle's Answer to Security Risks in The Internet of AI Agents](https://coinpedia.org/information/hypercycles-answer-to-security-risks-in-the-internet-of-ai-agents/#:~:text=Developers%20can%20leverage%20the%20decentralized,offering%20services%20to%20other%20AIs))4„Äë). Scalability is a concern here: if an AIM is very popular, a single HyperBox might not handle all requests. However, the marketplace can deploy the same AIM on multiple HyperBoxes (multiple users can deploy their own instances on different nodes). In the future, we could even allow one user to scale out across multiple boxes for load balancing ‚Äì but that‚Äôs beyond MVP. Security-wise, by not exposing the node directly and requiring wallet signatures for actions, we prevent abuse like someone spamming an AIM with requests without paying or calling a node directly outside the platform. The use of the user‚Äôs own wallet for payment is decentralized and trustless ‚Äì our marketplace doesn‚Äôt handle those funds directly (except possibly facilitating initial NFT sales). This reduces our liability and aligns with Web3 principles.

## Phase 8: Profiles, Ratings, and Messaging System

**Objectives:** Build out the social features: user profiles, a messaging system for communication between AIM developers, HyperBox owners, and users, and a rating/review mechanism. Also ensure both Cardano and EVM networks are fully supported in these features (e.g. testnet vs mainnet flags where needed).

- **Enhanced User Profiles:** Expand the profile page to show more information and actions:
  - Display the user‚Äôs **linked wallets** (e.g. show their Ethereum address and Cardano address, perhaps with icons). For privacy, only show partial addresses or give the user control to toggle visibility.
  - List the user‚Äôs **AIMs published** (if any) with links to those AIM pages.
  - List **HyperBoxes owned** (if any) with links.
  - Show average ratings: for developers (how users rated their AIMs), for HyperBox owners (how renters rated their hardware or service).
  - Allow profile personalization: maybe a profile picture (hosted off-chain, small upload to our server or IPFS) and social links.
  - **Wallet integration on profile:** allow user to link a new wallet (maybe they want to add a second EVM address). Also allow disconnecting a wallet (which in practice means just removing it from profile; we keep it in DB for historical records but mark as not active).
- **Messaging System:** Implement a private messaging feature for users to communicate:
  - Create a table **Messages**: `id, sender_id, receiver_id, content, timestamp, read_flag`. Use this to store messages centrally (encrypted messaging would be ideal, but initially plaintext in DB is fine with the understanding that this is a semi-trusted platform component).
  - UI: A simple mailbox accessible via a ‚ÄúMessages‚Äù link. Show conversations grouped by user. E.g. clicking on a user in your contacts shows the thread of messages (load last N messages, allow scrolling for history).
  - Integrate with profiles and listings:
    - On a HyperBox detail page, a ‚ÄúContact Owner‚Äù button that opens a message thread to the owner (e.g. if user has questions about the hardware or custom arrangements).
    - On an AIM page, ‚ÄúContact Developer‚Äù similarly.
    - Possibly on user profile pages, a ‚ÄúSend Message‚Äù if you are logged in.
  - Use Next.js API routes for sending and fetching messages. E.g. `POST /api/message` to send (with authentication ensuring `sender_id` matches logged in user), and `GET /api/messages?with=USER_ID` to fetch a conversation.
  - Optionally, implement web socket updates or periodic polling so that messages appear in real-time if both users are online. This can be done later; initially maybe just refresh on page load or provide a refresh button.
  - **Notifications:** Indicate new unread messages with a small badge in the UI (could poll `/api/messages/unread_count`).
- **Ratings & Reviews:** After an interaction (deployment or purchase), prompt users to leave feedback:
  - For AIMs: after using an AIM, a user can rate it (1-5 stars) and leave a comment review. Store in a **Reviews** table: `id, aim_id, reviewer_id, rating, comment, timestamp`. Compute average rating per AIM.
  - For HyperBoxes: after deploying on someone‚Äôs HyperBox, the user can similarly rate the experience (was the service fast, reliable?). Store fields like `hyperbox_id, reviewer_id, rating, comment`.
  - Use these ratings to display on listings: e.g. ‚Äú‚≠ê 4.8 (10 reviews)‚Äù on an AIM card, or ‚Äú‚≠ê 5.0 (3 reviews)‚Äù on HyperBox card.
  - Also aggregate at user profile: if a user is an AIM developer, maybe average of all their AIM ratings; if they are a HyperBox owner, average of their box ratings.
  - **Incentivize quality:** This helps future users choose good AIMs and boxes. A poorly rated AIM or HyperBox will be less likely chosen, pushing participants to maintain quality (AIM devs improving models, HyperBox owners ensuring uptime).
- **Testnet vs Mainnet Support:** Ensure that all features work on both testnet and mainnet environments:
  - By this phase, we should have smart contracts (NFTs, etc.) potentially deployed on testnets (e.g. Mumbai for Polygon, Goerli for Ethereum, etc., and Cardano Preview for Cardano). Provide a configuration to switch the contract addresses based on an environment variable or dropdown in the UI. For instance, have a setting in the app for ‚ÄúNetwork: Goerli vs Ethereum‚Äù which the user can toggle (along with their wallet).
  - The wallet integration (Phase 3) already accounts for connecting to different networks. We need to ensure the contract calls in Phase 5 know which network they are on. Perhaps use the chain ID from the connected wallet to pick the right addresses.
  - For Cardano, if in mainnet mode, ensure Mesh is connecting to mainnet. If in testnet mode, to test any Cardano-specific features (though we haven‚Äôt implemented a Cardano-specific contract, users might still want to see their Cardano test ADA balance or such ‚Äì not critical to our logic but the connection should allow it).
  - Provide clear labeling in the UI (maybe in the footer or top-right) ‚ÄúYou are on Ethereum Testnet (Goerli)‚Äù to avoid confusion. And possibly restrict certain actions on testnet (for example, real purchases might be disabled).
  - **Dual-Network Data:** One tricky aspect is data separation. If we want to keep test usage separate, we might use a separate database instance or at least mark entries with a network. For example, if someone lists an AIM and mints an NFT on Mumbai testnet, that shouldn‚Äôt appear in mainnet mode. We can add a `network` column to relevant tables (AIM, HyperBox, etc.) indicating if this record is for testing. Or simpler, run a separate deployment of the app for test vs main. But a single app that can toggle might mix data. Safer: from Phase 1, we could have included a field `environment` on listings. We now enforce filtering by that: if the app is in mainnet mode, only show mainnet listings (i.e. those minted on mainnet or marked as such).
  - By accounting for this, we allow users to experiment on testnet without polluting real marketplace data.
- **Cross-Chain Interactions:** If possible, demonstrate one cross-chain scenario. For example, a user could pay for an AIM NFT on Ethereum but deploy it on a HyperBox that is known only via Cardano identity. This is advanced and not required, but our design enables it because the profile links both addresses. Essentially, since deployment checks NFT ownership, as long as it‚Äôs the same person controlling both wallets, we could allow a user to prove ownership of an Ethereum NFT while using a Cardano-based HyperBox. We might implement a verification: user signs a message with their Ethereum wallet and Cardano wallet proving they are one entity. This could tie into an eventual DID solution. This is optional and probably beyond MVP, but it‚Äôs worth noting in documentation that our platform could evolve to support that seamlessly, making it truly chain-agnostic.
- **Moderation and Spam Prevention:** With messaging and reviews, we need some basic moderation:
  - Prohibit obscene or abusive content in messages/reviews ‚Äì at least state in terms that such behavior can get one banned. Possibly implement a simple word filter or allow users to report abuse (a ‚ÄúReport‚Äù button on messages).
  - Avoid spam: limit how many messages a new user can send per minute, etc., to prevent someone from spamming all HyperBox owners. Similarly, maybe restrict messaging to only when there‚Äôs a relevant connection (e.g. a user can message an owner only if they have an interest like wanting to deploy on their box).
  - These are more policy issues, but our system should be designed to handle user reports and admin actions (like deleting a review or banning a user) ‚Äì we won‚Äôt flesh out an admin panel here but mention the need.
- **UI/UX:** Integrate these features cleanly:
  - Perhaps a tabbed interface on profile: ‚ÄúMy AIMs | My HyperBoxes | Reviews | Settings‚Äù.
  - Messaging could be a chat-style popup or a dedicated page. Ensure it‚Äôs mobile-friendly (maybe use a responsive drawer).
  - Ratings: use recognizable star icons. Possibly show them on listing cards as small stars under the name.
  - If a user is both an AIM dev and box owner, they might have two ratings ‚Äì we can display both separately (e.g. ‚ÄúAIM Developer Rating: 4.7, HyperBox Provider Rating: 5.0‚Äù).
- **Testing & Quality Assurance:** At this phase, the platform is feature-complete. Conduct end-to-end tests on testnet:
  - Simulate full flows: developer publishes AIM (testnet NFT minted), owner lists HyperBox, user buys AIM NFT, deploys on HyperBox, interacts, sends message to owner ‚Äúthanks!‚Äù, leaves a 5-star review for both the AIM and HyperBox.
  - Ensure data consistency (e.g. after transaction, ownership changed; after undeploy, HyperBox marked free; reviews showing correctly).
  - Perform security testing: try to access someone else‚Äôs messages via API (should be blocked by auth), SQL injection in profile fields, etc.

*Rationale:* Social features like messaging and profiles turn a functional marketplace into a community hub, which is important for growth. Users can build trust: e.g., a new user might message a HyperBox owner to ask ‚ÄúCan your node handle a stable diffusion model?‚Äù before deployment. Or a HyperBox owner might message an AIM developer for support if their module isn‚Äôt running properly. These interactions **facilitate cooperation in a decentralized setting**, which is crucial because unlike a centralized cloud service, here the ‚Äúoperators‚Äù and ‚Äúdevelopers‚Äù are different parties. The review system introduces accountability and incentive for good behavior. If a HyperBox owner routinely stops jobs abruptly or has poor hardware performance, they‚Äôll get bad ratings and fewer customers. If an AIM is overpriced or underperforming, users will flag that in reviews, guiding others. This mirrors platforms like Airbnb or Uber where both sides are reviewed.

By Phase 8‚Äôs completion, the marketplace is not only technically robust but also user-friendly and trust-enabled. All the while, it supports both **Cardano and EVM** environments: for example, a developer from the Cardano community could list an AIM and accept ADA or a Cardano native token if we extended to that, and an Ethereum user could rent GPU time paying in HyPC or ETH. The dual integration might be refined, but we have ensured the structure to accommodate it. 

Security in profiles/messaging is addressed by standard web best practices (sanitize inputs, use parameterized queries to avoid injection, etc.). There is also the aspect of protecting user data ‚Äì since this is Web3, perhaps we encourage users not to share sensitive info in messages, but we as platform should treat private messages with confidentiality (encrypt at rest if possible). However, since the user‚Äôs identity is essentially public wallet addresses, privacy concerns are slightly different than email (still, content of messages can be private). We should consider GDPR etc. if applicable, but as minimal personal data is stored (mostly pseudonymous), compliance is easier.

## Phase 9: Testing, Launch on Testnet, and Mainnet Deployment

**Objectives:** Rigorously test the entire system in a testnet environment, fix any issues, then deploy the marketplace to mainnet. Also set up the infrastructure for continuous deployment, monitoring, and customer support channels.

- **Internal Testing on Testnet:**
  - Use **Ethereum Goerli or Polygon Mumbai** and Cardano Preprod as test networks. Deploy our smart contracts (AIM NFT contract, maybe marketplace contract) to these networks.
  - Configure the Next.js app to point to these contracts and set the default network to test. (We might host a test version of the site at a separate URL).
  - Have a small group (developers and maybe early adopters) run through all use cases: listing, buying, deploying, messaging, etc. Gather feedback on UX (was anything confusing? did wallet connections work smoothly across different browsers?).
  - Pay attention to the performance of cross-domain interactions ‚Äì if the HyperBox node is remote, are calls fast enough? If not, consider caching mechanisms or optimizing data payloads. Perhaps the first call (container pull) is slow ‚Äì we should set expectations in UI (like ‚ÄúDeploying‚Ä¶ this may take a couple of minutes on first run‚Äù if large model).
  - Security testing: Engage in **penetration testing** mode on testnet. Attempt to:
    - Forge a deployment without owning NFT (should be blocked).
    - Access another user‚Äôs deployed AIM (maybe try to call a running AIM‚Äôs endpoint without the UI ‚Äì if someone obtains the HyperBox URL, can they misuse it? The HyperCycle node should ideally enforce that only the payer of a task gets the response, but we might not rely on that. We could include an auth token in the requests to tie them to the deployment initiator).
    - Spam the messaging system or XSS in reviews ‚Äì ensure our frontend properly escapes any user-generated content (we should use a library or React‚Äôs automatic escaping for content).
    - Also test failure modes: what if the HyperBox goes offline mid-use? The UI should handle timeouts gracefully and inform the user ‚ÄúThe HyperBox became unresponsive. Your session may have ended.‚Äù Similarly, if a transaction fails (user rejects MetaMask), handle that (‚ÄúPayment needed to continue‚Äù).
  - Optimize any slow queries or memory issues found during testing. For instance, loading all messages for a heavy user might need pagination.
- **Scalability Checks:** On testnet, simulate a larger load:
  - Use scripts to create, say, 50 dummy AIM listings and 50 HyperBox listings to see how the UI handles it. Ensure our listing pages are paginated or lazy-loaded to not choke.
  - Simulate multiple simultaneous deployments (if possible, have multiple HyperBoxes and deploy AIMs concurrently) to see if our backend and the HyperCycle nodes hold up. This may be limited by available testers/nodes.
  - Profile the Next.js server performance ‚Äì if our proxy or other API calls are heavy, consider caching frequently used data. For example, HyperBox specs don‚Äôt change often, so cache them. AIM manifests can be cached after first fetch.
  - If needed, scale out the backend: maybe separate the proxy service (which could see heavy traffic when many users use AIMs) from the main Next.js server. We could containerize the proxy and replicate it.
  - Database scaling: ensure indexes on important fields (like `aim_id` in reviews, or `owner_id` in hyperboxes) for fast joins and lookups. If volume grows, consider read replicas or using a managed service.
- **Mainnet Launch Preparation:**
  - Deploy the NFT contracts to Ethereum mainnet (or a chosen chain like Polygon for lower fees if targeting wider usage). Double-check addresses and update config.
  - Migrate any test data that should persist to mainnet or decide to start fresh. Likely, we start fresh (test data is not carried over).
  - Make sure all environment variables (API keys, contract addresses, node endpoints) are set for production. For instance, if HyperCycle has a specific mainnet endpoint or if using a service like Infura/Alchemy for blockchain access, configure those.
  - Security final pass: get a third-party audit on the smart contracts (if complex) before mainnet. The contracts are relatively simple (NFT and maybe marketplace), but an audit (like the Paladin one for HyperCycle‚Äôs share toke ([[PDF] For HyperCycle (Share Tokens) - Smart Contract Security Assessment](https://paladinsec.co/assets/audits/20231214_Paladin_HyperCycleShareTokens_Final_Report.pdf#:~:text=,share%20revenue%20with%20other))8„Äë) can ensure no vulnerabilities on-chain.
  - Also audit the web app for any severe vulnerabilities. Although it‚Äôs a dApp, typical web vulnerabilities still apply.
- **Deployment and Monitoring:**
  - Deploy the Next.js app to a reliable host. Possibly use Docker/Kubernetes for the backend so we can scale it. Ensure the domain has SSL (for wallet connections and general security).
  - Set up monitoring tools: server uptime monitors, error logging (Sentry or similar for frontend and backend errors).
  - Set up analytics to track usage (but carefully, as users might not want to be tracked extensively; perhaps just aggregate metrics without personal data).
  - Create a support channel (maybe a Discord or Telegram, given the crypto community context) where users can report issues. Also prepare a FAQ/Documentation (how to connect a wallet, how to acquire HyPC tokens to use in the platform, etc.). Some of this info can go on a help page on the site as well.
- **Mainnet Launch:**
  - Announce and onboard initial users. Possibly coordinate with the HyperCycle community to list real AIMs and HyperBox providers who were early adopters (maybe those who bought HyperAI Boxes).
  - Keep an eye on early transactions on mainnet: are NFT sales going through? Is the gas cost acceptable for using the AIM (HyPC token transfers might be on HyperCycle chain which is feeless or minimal, but if it‚Äôs on Ethereum as ERC-20, gas could be an issue ‚Äì if so, consider Layer2 or sidechain for transactions).
  - Ensure support for multiple currencies if needed (perhaps HyperCycle might use multiple tokens; e.g., AGIX or NTX for certain payments as mentioned in the ecosyst ([HyperCycle ‚Äî The Journey to a Fully AI-Capable Blockchain | by Ben Goertzel | SingularityNET | Medium](https://medium.com/singularitynet/hypercycle-the-journey-to-a-fully-ai-capable-blockchain-9d2b7431cfa1#:~:text=On%20the%20tokenomic%20level%2C%20the,needed%20to%20provide%20their%20services))5„Äë ‚Äì not a direct requirement, but be aware).
- **Continuous Improvement:** Even post-launch, plan for future:
  - Add more automation: e.g., automated container build for AIM from source code, integration with CI so developers can push AIM updates easily.
  - Expand cross-chain: support Cardano native NFTs for AIM licensing if that becomes relevant (the marketplace could support a Cardano-native asset as a license token just as we did ERC-721).
  - Consider a **DAO governance** aspect: maybe the community votes on featured AIMs or on changes to marketplace fees, etc. This could be a long-term goal and would involve launching a governance token or using HYPC if appropriate.
  - **Security maintenance:** regular updates to dependencies, monitoring for new exploits (e.g., if a vulnerability in Mesh JS or ethers.js is found, update promptly).

*Rationale:* This final phase ensures the product is robust and ready for real users on the main blockchain networks. By testing thoroughly on testnets, we mimic the mainnet conditions without risking real value. We also address scalability and security holistically here, summarizing best practices:
  - We implemented caching and indexing to handle high load.
  - The architecture is stateless enough to scale horizontally (especially if we decouple the AIM call proxy).
  - Sensitive operations (minting, payments) are audited and carefully monitored.
  - Throughout the development, we adhered to security best practices: wallet signatures for critical actions, principle of least privilege (e.g., our marketplace contract only does what‚Äôs needed, our backend only interacts with nodes and contracts in controlled ways), and data validation. By Phase 9, we verify those with real-world testing and external audits.

**Scalability & Security Highlights (Summary):** The design ensures that adding more AIMs or HyperBoxes mainly increases load on the database and perhaps on the blockchain (more NFTs). We can shard or optimize as needed; the critical real-time part is AIM usage, which scales by HyperBox ‚Äì since each HyperBox is a separate node, the compute load is decentralized. Our system just coordinates, so it can handle many concurrent sessions as long as the central coordination isn‚Äôt a bottleneck. Using a proxy might centralize some network traffic, but that can be scaled by load balancers. In terms of security, we addressed multiple layers:
  - **Smart Contracts:** Minimally designed (NFTs) and (presumably) audit ([[PDF] For HyperCycle (Share Tokens) - Smart Contract Security Assessment](https://paladinsec.co/assets/audits/20231214_Paladin_HyperCycleShareTokens_Final_Report.pdf#:~:text=,share%20revenue%20with%20other))8„Äë, reducing on-chain risk.
  - **Authentication:** Wallet-based, eliminating password breaches; and checks like NFT ownership to authorize actions.
  - **Data Security:** Only pseudonymous data stored, reducing privacy risk; communications like messages kept within platform and not on-chain to avoid unwanted exposure.
  - **Operational Security:** Monitoring and fail-safes for downtime, plus the rating system to quickly identify bad actors or failing nodes.

By following this roadmap, we will have developed a comprehensive decentralized marketplace that embodies the HyperCycle vision of an ‚ÄúInternet of AI‚Äù ‚Äì connecting AI service providers and compute providers in a secure, user-friendly, and scalable mann ([HyperCycle's Answer to Security Risks in The Internet of AI Agents](https://coinpedia.org/information/hypercycles-answer-to-security-risks-in-the-internet-of-ai-agents/#:~:text=The%20IoAA%20presents%20numerous%20opportunities,reduced%20developer%20costs%2C%20among%20others)) ([HyperCycle ‚Äî The Journey to a Fully AI-Capable Blockchain | by Ben Goertzel | SingularityNET | Medium](https://medium.com/singularitynet/hypercycle-the-journey-to-a-fully-ai-capable-blockchain-9d2b7431cfa1#:~:text=somehow%20pay%20for%20these%20hardware,a%20spinoff%20of%20SingularityNET%20Foundation))0„Äë. Each phase built upon the previous, incrementally adding functionality and ensuring no aspect is overlooked (from tech to UX to security). The end result is a platform where AI modules (AIMs) can be listed and monetized and anyone with a HyperBox can contribute computing power and earn, all mediated through a next-gen dApp interface rather than a centralized entity.

**Sources:**

- HyperCycle vision and need for AI agent marketplac ([HyperCycle's Answer to Security Risks in The Internet of AI Agents](https://coinpedia.org/information/hypercycles-answer-to-security-risks-in-the-internet-of-ai-agents/#:~:text=Marketplaces%20are%20decentralized%20platforms%20where,even%20if%20one%20node%20fails)) ([HyperCycle ‚Äî The Journey to a Fully AI-Capable Blockchain | by Ben Goertzel | SingularityNET | Medium](https://medium.com/singularitynet/hypercycle-the-journey-to-a-fully-ai-capable-blockchain-9d2b7431cfa1#:~:text=somehow%20pay%20for%20these%20hardware,a%20spinoff%20of%20SingularityNET%20Foundation))0„Äë  
- HyperAppliance HyperBox concept and use of node licenses & ERC-721 for value shari ([Digital Investor x Hypercycle: "HyperAppliance" & ERC721?](https://defiance.media/video/digital-investor-x-hypercycle-hyperappliance-erc721/#:~:text=,potential%20energy%20and%20thermal%20energy)) ([Digital Investor x Hypercycle: "HyperAppliance" & ERC721?](https://defiance.media/video/digital-investor-x-hypercycle-hyperappliance-erc721/#:~:text=,alternative%20to%20traditional%20space%20heaters))3„Äë  
- HyperAI Box onboarding (plug, wallet, license, g ([HyperCycling Towards Superintelligence: Revolutionizing AI and Decentralized Networks | by SingularityNET Ambassadors | Medium](https://medium.com/@singularitynetambassadors/hypercycling-towards-superintelligence-revolutionizing-ai-and-decentralized-networks-8d04e3cac0bc#:~:text=The%20HyperAIBoxes%20come%20with%20pre,your%20computing%20power%20even%20more))4„Äë  
- HypC JS API ‚Äì AIM info, manifest (endpoints & license), and task execution via MetaMa ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=,current%20status%20and%20GPU%20resources)) ([GitHub - hypercycle-development/hypc-js: Javascript API for HyPC nodes](https://github.com/hypercycle-development/hypc-js#:~:text=options%2C%20so%20you%20can%20specify,decoded%20task%20result))7„Äë